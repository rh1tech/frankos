// ---------------------------------------------------------------- //
// This file is autogenerated by pioasm version 2.2.0; do not edit! //
// ---------------------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------ //
// ps2_rx //
// ------ //

#define ps2_rx_wrap_target 0
#define ps2_rx_wrap 11
#define ps2_rx_pio_version 1

static const uint16_t ps2_rx_program_instructions[] = {
            //     .wrap_target
    0x20a0, //  0: wait   1 pin, 0
    0x2020, //  1: wait   0 pin, 0
    0xe02a, //  2: set    x, 10
    0xa042, //  3: nop
    0xa042, //  4: nop
    0x4002, //  5: in     pins, 2
    0x20a0, //  6: wait   1 pin, 0
    0x004a, //  7: jmp    x--, 10
    0x8020, //  8: push   block
    0x0000, //  9: jmp    0
    0x2020, // 10: wait   0 pin, 0
    0x0003, // 11: jmp    3
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program ps2_rx_program = {
    .instructions = ps2_rx_program_instructions,
    .length = 12,
    .origin = -1,
    .pio_version = ps2_rx_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config ps2_rx_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + ps2_rx_wrap_target, offset + ps2_rx_wrap);
    return c;
}

#include "hardware/pio.h"
#include "hardware/clocks.h"
/**
 * Initialize PS/2 receive state machine.
 * 
 * @param pio      PIO instance (pio0 or pio1)
 * @param sm       State machine number (0-3)
 * @param offset   Program offset in PIO instruction memory
 * @param clk_pin  GPIO pin for PS/2 clock (DATA must be clk_pin + 1)
 */
static inline void ps2_rx_program_init(PIO pio, uint sm, uint offset, uint clk_pin) {
    uint data_pin = clk_pin + 1;
    pio_sm_config c = ps2_rx_program_get_default_config(offset);
    // IN pin base = CLK pin, so:
    //   'wait N pin 0' checks CLK
    //   'in pins, 2' reads CLK (bit 0) and DATA (bit 1)
    sm_config_set_in_pins(&c, clk_pin);
    // Shift LEFT, autopush after 22 bits (11 samples * 2 bits)
    // Left shift puts first sample in LSB, which makes decoding easier
    sm_config_set_in_shift(&c, false, true, 22);
    // Join FIFOs for deeper RX buffer (32 entries)
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    // Clock divider: PS/2 runs at 10-16.7 kHz
    // We want at least 8 SM cycles per PS/2 clock for reliable sampling
    float div = (float)clock_get_hz(clk_sys) / (8.0f * 16700.0f);
    sm_config_set_clkdiv(&c, div);
    // Initialize GPIO pins for PIO
    pio_gpio_init(pio, clk_pin);
    pio_gpio_init(pio, data_pin);
    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, clk_pin, 2, false);
    // Enable internal pull-ups (PS/2 is open-collector)
    gpio_pull_up(clk_pin);
    gpio_pull_up(data_pin);
    // Initialize and enable state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
/**
 * Extract data byte from raw 22-bit PIO frame.
 * 
 * With LEFT shift, first sample (start) is at highest bits:
 *   Bits 21:20 = Sample 0 (start bit)
 *   Bits 19:18 = Sample 1 (data bit 0)
 *   ...
 *   Bits 1:0   = Sample 10 (stop bit)
 * 
 * Each sample has CLK in bit 0, DATA in bit 1.
 * 
 * Returns: data byte if valid, -1 if frame error, -2 if parity error
 */
static inline int ps2_rx_decode_frame(uint32_t raw) {
    // Extract each DATA bit (bit 1 of each 2-bit sample)
    // First sample is at highest position due to left shift
    uint8_t start  = (raw >> 21) & 1;  // Sample 0
    uint8_t d0     = (raw >> 19) & 1;  // Sample 1
    uint8_t d1     = (raw >> 17) & 1;  // Sample 2
    uint8_t d2     = (raw >> 15) & 1;  // Sample 3
    uint8_t d3     = (raw >> 13) & 1;  // Sample 4
    uint8_t d4     = (raw >> 11) & 1;  // Sample 5
    uint8_t d5     = (raw >> 9) & 1;   // Sample 6
    uint8_t d6     = (raw >> 7) & 1;   // Sample 7
    uint8_t d7     = (raw >> 5) & 1;   // Sample 8
    uint8_t parity = (raw >> 3) & 1;   // Sample 9
    uint8_t stop   = (raw >> 1) & 1;   // Sample 10
    // Validate start bit (must be 0) and stop bit (must be 1)
    if (start != 0 || stop != 1) {
        return -1;  // Frame error
    }
    // Reconstruct data byte (PS/2 sends LSB first)
    uint8_t data = d0 | (d1 << 1) | (d2 << 2) | (d3 << 3) |
                   (d4 << 4) | (d5 << 5) | (d6 << 6) | (d7 << 7);
    // Verify odd parity
    uint8_t calc_parity = 1;
    uint8_t temp = data;
    while (temp) {
        calc_parity ^= (temp & 1);
        temp >>= 1;
    }
    if (parity != calc_parity) {
        return -2;  // Parity error
    }
    return data;
}

#endif

